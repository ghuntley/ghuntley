{ config, pkgs, ... }:

{
  imports =
    [
      # Include the results of the hardware scan.
      ./hardware-configuration.nix
      (fetchTarball "https://github.com/msteen/nixos-vscode-server/tarball/master")
    ];

  # Use GRUB2 as the boot loader.
  # We don't use systemd-boot because Hetzner uses BIOS legacy boot.
  boot.loader.systemd-boot.enable = false;
  boot.loader.grub = {
    enable = true;
    efiSupport = false;
    devices = [ "/dev/disk/by-id/ata-SAMSUNG_MZ7LM480HCHP-00003_S1YJNXAG800126" "/dev/disk/by-id/ata-SAMSUNG_MZ7LM480HCHP-00003_S1YJNXAG800130" ];
    copyKernels = true;
  };
  boot.supportedFilesystems = [ "zfs" ];

  # https://www.kernel.org/doc/Documentation/filesystems/nfs/nfsroot.txt
  boot.kernelParams = [ "ip=148.251.233.2:148.251.233.2:148.251.233.1:255.255.255.224" ];

  # Network card drivers.
  # https://unix.stackexchange.com/questions/41817/linux-how-to-find-the-device-driver-used-for-a-device
  boot.initrd.kernelModules = [ "igb" ];

  boot.initrd.network = {
    # Static ip addresses can be configured using the ip argument in kernel command line:
    # https://www.kernel.org/doc/Documentation/filesystems/nfs/nfsroot.txt
    enable = true;
    ssh = {
      enable = true;
      # To prevent ssh clients from freaking out because a different host key is used,
      # a different port for ssh is useful (assuming the same host has also a regular sshd running)
      port = 22;

      # hostKeys paths must be unquoted strings, otherwise you'll run into issues with boot.initrd.secrets
      # the keys are copied to initrd from the path specified; multiple keys can be set
      # you can generate any number of host keys using
      # Generating public/private ed25519 key pair.

      hostKeys = [ /etc/ssh/ssh_boot_ed25519_key ];

      # public ssh key used for login
      authorizedKeys = [ "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFiX7qvQS3QjzL8y31KxMPn5EOyufjgz2YuRD3GNWcuR ghuntley@ghuntley.com" ];
    };

    # this will automatically load the zfs password prompt on login
    # and kill the other prompt so boot can continue
    postCommands = ''
      cat <<EOF > /root/.profile
      if pgrep -x "zfs" > /dev/null
      then
          zfs load-key -a
          killall zfs
      else
          echo "zfs not running -- maybe the pool is taking some time to load for some unforseen reason."
      fi
      EOF
    '';
  };

  networking.hostName = "hetzner-ghuntley-blank";
  networking.hostId = "deadbeef";

  # Network (Hetzner uses static IP assignments, and we don't use DHCP here)
  networking.useDHCP = false;
  networking.interfaces."enp4s0".ipv4.addresses = [
    {
      address = "148.251.233.2";
      prefixLength = 24;
    }
  ];
  networking.interfaces."enp4s0".ipv6.addresses = [
    {
      address = "2a01:4f8:201:3108::1";
      prefixLength = 64;
    }
  ];
  networking.defaultGateway = "148.251.233.1";
  networking.defaultGateway6 = { address = "fe80::1"; interface = "enp4s0"; };
  networking.nameservers = [ "8.8.8.8" ];

  # Initial empty root password for easy login:
  users.users.root.initialHashedPassword = "";
  services.openssh.permitRootLogin = "prohibit-password";

  users.users.root.openssh.authorizedKeys.keys = [ "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFiX7qvQS3QjzL8y31KxMPn5EOyufjgz2YuRD3GNWcuR ghuntley@ghuntley.com" ];

  users.users.ghuntley = {
    isNormalUser = true;
    extraGroups = [ "git" "wheel" ];
    shell = pkgs.bash;
    openssh.authorizedKeys.keys = [ "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFiX7qvQS3QjzL8y31KxMPn5EOyufjgz2YuRD3GNWcuR ghuntley@ghuntley.com" ];
  };

  services.openssh.enable = true;

  services.zfs.autoScrub.enable = true;
  services.zfs.trim.enable = true;

  services.sanoid.enable = true;
  services.sanoid.interval = "hourly";
  #   services.sanoid.settings = {
  #     autosnap=1;
  #     autoprune="yes";
  #     hourly=48;
  #     daily=30;
  #     weekly=0;
  #     monthly=0;
  #     yearly=0;
  #   };

  services.sanoid.datasets."rpool/root".autosnap = true;
  services.sanoid.datasets."rpool/root/etc".autosnap = true;
  services.sanoid.datasets."rpool/root/home".autosnap = true;
  services.sanoid.datasets."rpool/root/srv".autosnap = true;
  services.sanoid.datasets."rpool/root/nix".autosnap = false;
  services.sanoid.datasets."rpool/tmp".autosnap = false;

  services.vscode-server.enable = true;

  programs.mosh.enable = true;

  nix.settings.experimental-features = [ "nix-command" "flakes" ];

  services.cachix-agent.enable = true;


  environment.systemPackages = [
    pkgs.ack
    pkgs.bind
    pkgs.cachix
    pkgs.curl
    pkgs.direnv
    pkgs.dos2unix
    pkgs.git-lfs
    pkgs.gitAndTools.gitFull
    pkgs.htop
    pkgs.iftop
    pkgs.inetutils
    pkgs.iotop
    pkgs.lsof
    pkgs.neovim
    pkgs.ntp
    pkgs.opentelemetry-collector
    pkgs.p7zip
    pkgs.rpl
    pkgs.tmux
    pkgs.tree
    pkgs.unzip
    pkgs.wget
    pkgs.vim
    pkgs.zip
  ];


  networking.nat = {
    enable = true;
    internalInterfaces = [ "ve-+" ];
    externalInterface = "enp4s0";
    # Lazy IPv6 connectivity for the container
    enableIPv6 = true;
  };

  containers.

  containers.headscale = {
    autoStart = true;
    privateNetwork = true;
    enableTun = true;
    hostAddress = "192.168.100.10";
    localAddress = "192.168.100.11";
    hostAddress6 = "fc00::1";
    localAddress6 = "fc00::2";

    bindMounts =
      {
        "/var/lib/headscale" = {
          hostPath = "/srv/headscale/var/lib/headscale";
          isReadOnly = false;
        };
      };

    config = { config, pkgs, ... }: {

      services.headscale.enable = true;
      services.headscale.derp.autoUpdate = true;
      services.headscale.derp.updateFrequency = "5m";
      services.headscale.ephemeralNodeInactivityTimeout = "30m";
      services.headscale.database.type = "sqlite3";
      services.headscale.dns.magicDns = true;
      services.headscale.dns.baseDomain = "ts.fediversehosting.net";

      system.stateVersion = "22.05";

      networking.firewall = {
        enable = true;
        allowedTCPPorts = [ 80 ];
      };

      # Manually configure nameserver. Using resolved inside the container seems to fail
      # currently
      environment.etc."resolv.conf".text = "nameserver 8.8.8.8";

    };
  };


  # This value determines the NixOS release with which your system is to be
  # compatible, in order to avoid breaking some software such as database
  # servers. You should change this only after NixOS release notes say you
  # should.
  system.stateVersion = "22.05"; # Did you read the comment?

}
